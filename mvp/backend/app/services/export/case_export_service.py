"""
CaseExportService - Orchestrates the complete case export process.

This service:
1. Creates export records
2. Generates section content
3. Builds PDF documents
4. Calculates integrity hashes
5. Stores export files
"""

import uuid
import hashlib
import time
from datetime import date, datetime
from typing import Optional
from pathlib import Path

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload

from app.models.case import Case
from app.models.user import User
from app.models.export import CaseExport, ExportSection, SECTION_TYPES
from app.models.audit import EventLog
from app.services.export.redaction import RedactionService
from app.services.export.pdf_builder import ExportPDFBuilder, calculate_content_hash
from app.services.export.generators.base import GeneratorContext, SectionContent
from app.services.export.generators import get_registry


class CaseExportService:
    """
    Service for creating and managing case export packages.

    Usage:
        service = CaseExportService(db)
        export = await service.create_export(
            case_id="...",
            user_id="...",
            package_type="court",
            date_start=date(2024, 1, 1),
            date_end=date(2024, 12, 31),
        )
    """

    # Export file storage path (relative to project)
    EXPORT_STORAGE_PATH = Path("exports")

    def __init__(self, db: AsyncSession):
        self.db = db
        self._registry = get_registry()

    async def create_export(
        self,
        case_id: str,
        user_id: str,
        package_type: str,
        date_start: date,
        date_end: date,
        claim_type: Optional[str] = None,
        claim_description: Optional[str] = None,
        redaction_level: str = "standard",
        sections: Optional[list[str]] = None,
        message_content_redacted: bool = False,
        generator_name: str = "Unknown",
    ) -> CaseExport:
        """
        Create a new case export package.

        Args:
            case_id: ID of the case to export
            user_id: ID of the user generating the export
            package_type: "investigation" or "court"
            date_start: Start of date range
            date_end: End of date range
            claim_type: Type of claim (for investigation packages)
            claim_description: Description of claim
            redaction_level: PII redaction level
            sections: Specific sections to include (or None for defaults)
            message_content_redacted: Whether to fully redact message content
            generator_name: Name of person generating export

        Returns:
            Created CaseExport record
        """
        start_time = time.time()

        # Generate export number
        export_number = self._generate_export_number()

        # Determine sections to include
        section_types = sections or self._registry.get_default_sections(package_type)

        # Create export record
        export = CaseExport(
            id=str(uuid.uuid4()),
            case_id=case_id,
            generated_by=user_id,
            generator_type="parent",  # Could be "professional" in future
            export_number=export_number,
            package_type=package_type,
            claim_type=claim_type,
            claim_description=claim_description,
            date_range_start=date_start,
            date_range_end=date_end,
            sections_included=section_types,
            redaction_level=redaction_level,
            message_content_redacted=message_content_redacted,
            sealed_items_included=False,
            status="generating",
            download_count=0,
            is_permanent=False,
        )

        self.db.add(export)
        await self.db.commit()

        try:
            # Generate watermark
            watermark = f"Generated by: {generator_name} | {datetime.utcnow().strftime('%Y-%m-%d')} | Export: {export_number}"
            export.watermark_text = watermark

            # Get case info for PDF
            case_result = await self.db.execute(
                select(Case).where(Case.id == case_id)
            )
            case = case_result.scalar_one()

            # Create context for generators
            redaction_service = RedactionService(
                db=self.db,
                level=redaction_level
            )
            await redaction_service.initialize()

            context = GeneratorContext(
                db=self.db,
                case_id=case_id,
                date_start=date_start,
                date_end=date_end,
                redaction_service=redaction_service,
                message_content_redacted=message_content_redacted,
                claim_type=claim_type,
                claim_description=claim_description,
            )

            # Generate all sections
            section_contents = await self._registry.generate_sections(
                context=context,
                section_types=section_types,
                package_type=package_type,
            )

            # Store section data
            evidence_counts = {}
            for content in section_contents:
                section = ExportSection(
                    id=str(uuid.uuid4()),
                    export_id=export.id,
                    section_type=content.section_type,
                    section_order=content.section_order,
                    section_title=content.section_title,
                    content_json=content.content_data,
                    content_hash=hashlib.sha256(
                        str(content.content_data).encode()
                    ).hexdigest(),
                    evidence_count=content.evidence_count,
                    data_sources=content.data_sources,
                    generation_time_ms=content.generation_time_ms,
                )
                self.db.add(section)
                evidence_counts[content.section_type] = content.evidence_count

            export.evidence_counts = evidence_counts

            # Build PDF
            pdf_builder = ExportPDFBuilder(
                case_name=case.case_name,
                export_number=export_number,
                generated_by=generator_name,
                package_type=package_type,
                date_start=date_start.strftime("%B %d, %Y"),
                date_end=date_end.strftime("%B %d, %Y"),
                claim_type=claim_type,
                claim_description=claim_description,
                watermark_text=watermark,
            )

            pdf_bytes = pdf_builder.build(section_contents)

            # Calculate hashes
            content_hash = calculate_content_hash(pdf_bytes)
            chain_hash = await self._get_chain_hash(case_id, date_start, date_end)

            # Store PDF
            file_url = await self._store_pdf(export_number, pdf_bytes)

            # Update export record
            export.file_url = file_url
            export.file_size_bytes = len(pdf_bytes)
            export.page_count = self._count_pages(pdf_bytes)
            export.content_hash = content_hash
            export.chain_hash = chain_hash
            export.verification_url = f"https://verify.commonground.family/{export_number}"
            export.status = "completed"
            export.generated_at = datetime.utcnow()
            export.generation_time_seconds = int(time.time() - start_time)

            # Set expiration (30 days for non-permanent)
            from datetime import timedelta
            export.expires_at = datetime.utcnow() + timedelta(days=30)

            await self.db.commit()
            await self.db.refresh(export)

            return export

        except Exception as e:
            # Mark export as failed
            export.status = "failed"
            export.error_message = str(e)
            await self.db.commit()
            raise

    def _generate_export_number(self) -> str:
        """Generate unique export number."""
        date_part = datetime.utcnow().strftime("%Y%m%d")
        random_part = uuid.uuid4().hex[:4].upper()
        return f"EXP-{date_part}-{random_part}"

    async def _get_chain_hash(
        self,
        case_id: str,
        date_start: date,
        date_end: date
    ) -> Optional[str]:
        """Get the chain hash from EventLog for the date range."""
        start = datetime.combine(date_start, datetime.min.time())
        end = datetime.combine(date_end, datetime.max.time())

        result = await self.db.execute(
            select(EventLog)
            .where(EventLog.case_id == case_id)
            .where(EventLog.created_at >= start)
            .where(EventLog.created_at <= end)
            .order_by(EventLog.created_at.desc())
            .limit(1)
        )
        last_event = result.scalar_one_or_none()

        if last_event and last_event.current_hash:
            return last_event.current_hash

        return None

    async def _store_pdf(self, export_number: str, pdf_bytes: bytes) -> str:
        """Store PDF file and return URL/path."""
        # Ensure storage directory exists
        storage_path = self.EXPORT_STORAGE_PATH
        storage_path.mkdir(parents=True, exist_ok=True)

        # Save file
        filename = f"{export_number}.pdf"
        file_path = storage_path / filename

        with open(file_path, "wb") as f:
            f.write(pdf_bytes)

        # Return relative path as URL (in production, this would be a real URL)
        return f"/exports/{filename}"

    def _count_pages(self, pdf_bytes: bytes) -> int:
        """Count pages in PDF (approximate)."""
        # Simple estimation based on PDF structure
        # In production, use PyPDF2 or similar
        import re
        matches = re.findall(rb'/Type\s*/Page[^s]', pdf_bytes)
        return len(matches) or 1

    async def get_pdf_bytes(self, export_id: str) -> Optional[bytes]:
        """Get PDF bytes for an export."""
        result = await self.db.execute(
            select(CaseExport).where(CaseExport.id == export_id)
        )
        export = result.scalar_one_or_none()

        if not export or not export.file_url:
            return None

        # Extract filename from URL
        filename = export.file_url.split("/")[-1]
        file_path = self.EXPORT_STORAGE_PATH / filename

        if not file_path.exists():
            return None

        with open(file_path, "rb") as f:
            return f.read()

    async def verify_export(self, export_number: str) -> dict:
        """
        Verify an export's authenticity.

        Returns verification details including hash comparison.
        """
        result = await self.db.execute(
            select(CaseExport).where(CaseExport.export_number == export_number)
        )
        export = result.scalar_one_or_none()

        if not export:
            return {
                "valid": False,
                "message": "Export not found",
            }

        # Get stored PDF
        pdf_bytes = await self.get_pdf_bytes(export.id)

        if not pdf_bytes:
            return {
                "valid": False,
                "message": "PDF file not found",
            }

        # Calculate current hash
        current_hash = calculate_content_hash(pdf_bytes)

        # Compare with stored hash
        is_valid = current_hash == export.content_hash

        return {
            "valid": is_valid,
            "export_number": export.export_number,
            "generated_at": export.generated_at.isoformat() if export.generated_at else None,
            "stored_hash": export.content_hash,
            "calculated_hash": current_hash,
            "message": "Export verified successfully" if is_valid else "Hash mismatch - content may have been modified",
        }

    async def get_export_statistics(self, case_id: str) -> dict:
        """Get export statistics for a case."""
        result = await self.db.execute(
            select(CaseExport).where(CaseExport.case_id == case_id)
        )
        exports = list(result.scalars().all())

        total = len(exports)
        by_type = {}
        by_status = {}
        total_downloads = 0

        for export in exports:
            by_type[export.package_type] = by_type.get(export.package_type, 0) + 1
            by_status[export.status] = by_status.get(export.status, 0) + 1
            total_downloads += export.download_count

        return {
            "total_exports": total,
            "by_package_type": by_type,
            "by_status": by_status,
            "total_downloads": total_downloads,
        }
