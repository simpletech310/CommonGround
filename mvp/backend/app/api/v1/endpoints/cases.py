"""
Case management endpoints.
"""

from typing import List
from fastapi import APIRouter, Depends, Body, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.schemas.case import CaseCreate, CaseResponse, CaseUpdate
from app.services.case import CaseService

router = APIRouter()


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_case(
    case_data: CaseCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new co-parenting case.

    Initiates a case with the current user as the first participant and
    sends an invitation to the other parent via email.

    Returns:
        Case details and invitation token
    """
    case_service = CaseService(db)
    case, invitation_token = await case_service.create_case(case_data, current_user)

    return {
        "id": case.id,
        "case_name": case.case_name,
        "case_number": case.case_number,
        "state": case.state,
        "status": case.status,
        "created_at": case.created_at,
        "invitation_token": invitation_token,
        "message": "Case created successfully. Invitation sent to other parent."
    }


@router.post("/{case_id}/accept")
async def accept_invitation(
    case_id: str,
    invitation_token: str = Body(..., embed=True),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Accept a case invitation.

    Joins the user to the case as the second parent.

    Args:
        case_id: ID of the case
        invitation_token: Invitation token received via email

    Returns:
        Updated case details
    """
    case_service = CaseService(db)
    case = await case_service.accept_invitation(case_id, current_user, invitation_token)

    return {
        "id": case.id,
        "case_name": case.case_name,
        "status": case.status,
        "message": "Successfully joined the case!"
    }


@router.post("/accept-invite")
async def accept_court_invite(
    case_id: str = Body(...),
    role: str = Body(...),
    token: str = Body(None),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Accept a court-generated case invitation.

    This endpoint is used when a parent registers via an invite link
    generated by the court portal. It links the user to the case as
    a participant.

    Args:
        case_id: ID of the case to join
        role: Role in the case (petitioner/respondent)
        token: Optional invite token for verification

    Returns:
        Case details and success message
    """
    from sqlalchemy import select
    from app.models.case import Case, CaseParticipant

    # Get the case
    result = await db.execute(select(Case).where(Case.id == case_id))
    case = result.scalar_one_or_none()

    if not case:
        from fastapi import HTTPException
        raise HTTPException(status_code=404, detail="Case not found")

    # Check if user is already a participant
    existing_result = await db.execute(
        select(CaseParticipant).where(
            CaseParticipant.case_id == case_id,
            CaseParticipant.user_id == current_user.id
        )
    )
    existing = existing_result.scalar_one_or_none()

    if existing:
        return {
            "id": case.id,
            "case_name": case.case_name,
            "status": case.status,
            "message": "You are already a participant in this case."
        }

    # Determine parent_type based on role
    parent_type = "mother" if role == "petitioner" else "father"  # Default mapping

    # Create the participant record
    import uuid
    from datetime import datetime

    participant = CaseParticipant(
        id=str(uuid.uuid4()),
        case_id=case_id,
        user_id=current_user.id,
        role=role,
        parent_type=parent_type,
        is_active=True,
        joined_at=datetime.utcnow(),
        can_view_financials=True,
        can_view_messages=True,
        can_modify_agreement=True,
        can_invite_legal_access=True,
    )

    db.add(participant)

    # Check if case should be activated (both parents joined)
    participants_result = await db.execute(
        select(CaseParticipant).where(CaseParticipant.case_id == case_id)
    )
    all_participants = participants_result.scalars().all()

    # Including the new participant we just added
    total_participants = len(all_participants) + 1

    if total_participants >= 2 and case.status == "pending":
        case.status = "active"

    await db.commit()

    return {
        "id": case.id,
        "case_name": case.case_name,
        "status": case.status,
        "message": "Successfully joined the case!"
    }


@router.get("/", response_model=List[CaseResponse])
async def list_cases(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    List all cases for the current user.

    Returns all cases where the user is an active participant.

    Returns:
        List of cases
    """
    case_service = CaseService(db)
    cases = await case_service.get_user_cases(current_user)

    return [
        {
            "id": case.id,
            "case_name": case.case_name,
            "case_number": case.case_number,
            "state": case.state,
            "status": case.status,
            "created_at": case.created_at,
            "participants": [
                {
                    "id": p.id,
                    "role": p.role,
                    "parent_type": p.parent_type,
                    "user_id": p.user_id,
                    "is_active": p.is_active
                }
                for p in case.participants
            ]
        }
        for case in cases
    ]


@router.get("/{case_id}", response_model=CaseResponse)
async def get_case(
    case_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get detailed case information.

    Returns case details including participants and children.

    Args:
        case_id: ID of the case

    Returns:
        Case details
    """
    case_service = CaseService(db)
    case = await case_service.get_case(case_id, current_user)

    return {
        "id": case.id,
        "case_name": case.case_name,
        "case_number": case.case_number,
        "state": case.state,
        "status": case.status,
        "created_at": case.created_at,
        "participants": [
            {
                "id": p.id,
                "role": p.role,
                "parent_type": p.parent_type,
                "user_id": p.user_id,
                "is_active": p.is_active
            }
            for p in case.participants
        ]
    }


@router.put("/{case_id}", response_model=CaseResponse)
async def update_case(
    case_id: str,
    update: CaseUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update case details.

    Allows updating basic case information like name, county, and court.

    Args:
        case_id: ID of the case
        update: Fields to update

    Returns:
        Updated case details
    """
    case_service = CaseService(db)
    case = await case_service.update_case(case_id, update, current_user)

    return {
        "id": case.id,
        "case_name": case.case_name,
        "case_number": case.case_number,
        "state": case.state,
        "status": case.status,
        "created_at": case.created_at,
        "participants": [
            {
                "id": p.id,
                "role": p.role,
                "parent_type": p.parent_type,
                "user_id": p.user_id
            }
            for p in case.participants
        ]
    }


@router.post("/{case_id}/children")
async def add_child(
    case_id: str,
    child_data: dict = Body(...),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Add a child to a case.

    Args:
        case_id: ID of the case
        child_data: Child information

    Returns:
        Created child details
    """
    case_service = CaseService(db)
    child = await case_service.add_child(case_id, child_data, current_user)

    return {
        "id": child.id,
        "first_name": child.first_name,
        "last_name": child.last_name,
        "date_of_birth": child.date_of_birth,
        "case_id": child.case_id,
        "message": "Child added successfully"
    }


@router.put("/children/{child_id}")
async def update_child(
    child_id: str,
    child_data: dict = Body(...),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update child information.

    Args:
        child_id: ID of the child
        child_data: Updated child information

    Returns:
        Updated child details
    """
    case_service = CaseService(db)
    child = await case_service.update_child(child_id, child_data, current_user)

    return {
        "id": child.id,
        "first_name": child.first_name,
        "last_name": child.last_name,
        "date_of_birth": child.date_of_birth,
        "message": "Child updated successfully"
    }


@router.delete("/children/{child_id}")
async def delete_child(
    child_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Delete a child from a case.

    Args:
        child_id: ID of the child

    Returns:
        Success message
    """
    case_service = CaseService(db)
    await case_service.delete_child(child_id, current_user)

    return {"message": "Child deleted successfully"}


# Agreement endpoints for cases
@router.post("/{case_id}/agreement", status_code=status.HTTP_201_CREATED)
async def create_case_agreement(
    case_id: str,
    title: str = Body("Parenting Agreement", embed=True),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new agreement for a case.

    Initializes agreement with 18 section templates.

    Args:
        case_id: ID of the case
        title: Agreement title

    Returns:
        Created agreement with sections
    """
    from app.services.agreement import AgreementService

    agreement_service = AgreementService(db)
    agreement = await agreement_service.create_agreement(case_id, current_user, title)

    # Get sections for response
    await db.refresh(agreement, ["sections"])

    return {
        "id": agreement.id,
        "case_id": agreement.case_id,
        "title": agreement.title,
        "version": agreement.version,
        "status": agreement.status,
        "sections_count": len(agreement.sections),
        "message": "Agreement created with 18 section templates"
    }


@router.get("/{case_id}/agreements")
async def get_case_agreements(
    case_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get all agreements for a case.

    Returns:
        List of all agreements for the case
    """
    from app.services.agreement import AgreementService
    from app.schemas.agreement import AgreementResponse
    from sqlalchemy import select
    from app.models.agreement import Agreement

    # Verify access to case
    case = await CaseService(db).get_case(case_id, current_user)

    # Get all agreements for this case
    result = await db.execute(
        select(Agreement)
        .where(Agreement.case_id == case_id)
        .order_by(Agreement.created_at.desc())
    )
    agreements = result.scalars().all()

    return [
        AgreementResponse(
            id=agreement.id,
            case_id=agreement.case_id,
            family_file_id=agreement.family_file_id,
            title=agreement.title,
            version=agreement.version,
            status=agreement.status,
            petitioner_approved=agreement.petitioner_approved,
            respondent_approved=agreement.respondent_approved,
            effective_date=agreement.effective_date,
            pdf_url=agreement.pdf_url,
            created_at=agreement.created_at,
            updated_at=agreement.updated_at
        )
        for agreement in agreements
    ]


@router.get("/{case_id}/agreement")
async def get_case_agreement(
    case_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get the most relevant agreement for a case (active, or most recent).

    Returns:
        Agreement with all sections
    """
    from app.services.agreement import AgreementService
    from app.schemas.agreement import AgreementResponse, AgreementSectionResponse
    from fastapi import Response

    agreement_service = AgreementService(db)
    agreement = await agreement_service.get_case_agreement(case_id, current_user)

    if not agreement:
        return Response(status_code=status.HTTP_404_NOT_FOUND)

    # Calculate completion percentage
    completion = await agreement_service.get_completion_percentage(agreement)

    return {
        "agreement": AgreementResponse(
            id=agreement.id,
            case_id=agreement.case_id,
            family_file_id=agreement.family_file_id,
            title=agreement.title,
            version=agreement.version,
            status=agreement.status,
            petitioner_approved=agreement.petitioner_approved,
            respondent_approved=agreement.respondent_approved,
            effective_date=agreement.effective_date,
            pdf_url=agreement.pdf_url,
            created_at=agreement.created_at,
            updated_at=agreement.updated_at
        ),
        "sections": [
            AgreementSectionResponse(
                id=s.id,
                agreement_id=s.agreement_id,
                section_number=s.section_number,
                section_title=s.section_title,
                section_type=s.section_type,
                content=s.content,
                structured_data=s.structured_data,
                display_order=s.display_order,
                is_required=s.is_required,
                is_completed=s.is_completed
            )
            for s in sorted(agreement.sections, key=lambda x: x.display_order)
        ],
        "completion_percentage": completion
    }


@router.get("/{case_id}/aria-settings")
async def get_aria_settings(
    case_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get ARIA settings for a case.

    Returns the current ARIA configuration including:
    - Whether ARIA is enabled
    - AI provider being used (claude, openai, or regex)
    - When it was disabled (if applicable)
    - Who disabled it (if applicable)

    Args:
        case_id: ID of the case

    Returns:
        ARIA settings
    """
    case_service = CaseService(db)
    case = await case_service.get_case(case_id, current_user)

    return {
        "aria_enabled": case.aria_enabled,
        "aria_provider": case.aria_provider,
        "aria_disabled_at": case.aria_disabled_at,
        "aria_disabled_by": case.aria_disabled_by
    }


@router.patch("/{case_id}/aria-settings")
async def update_aria_settings(
    case_id: str,
    aria_enabled: bool = Body(..., embed=True),
    aria_provider: str = Body(default="claude", embed=True, regex="^(claude|openai|regex)$"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update ARIA settings for a case.

    Allows parents to enable/disable ARIA analysis and change the AI provider.
    When ARIA is disabled, this action is tracked for court documentation.

    Args:
        case_id: ID of the case
        aria_enabled: Whether to enable or disable ARIA
        aria_provider: AI provider to use (claude, openai, or regex)

    Returns:
        Updated ARIA settings
    """
    from datetime import datetime
    from app.models.case import Case
    from sqlalchemy import select, and_
    from app.models.case import CaseParticipant

    # Verify access
    result = await db.execute(
        select(CaseParticipant).where(
            and_(
                CaseParticipant.case_id == case_id,
                CaseParticipant.user_id == current_user.id,
                CaseParticipant.is_active == True
            )
        )
    )
    participant = result.scalar_one_or_none()

    if not participant:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have access to this case"
        )

    # Get case
    case_result = await db.execute(
        select(Case).where(Case.id == case_id)
    )
    case = case_result.scalar_one_or_none()

    if not case:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Case not found"
        )

    # Track when ARIA is disabled (before updating)
    old_aria_enabled = case.aria_enabled

    # Update settings
    case.aria_enabled = aria_enabled
    case.aria_provider = aria_provider

    # Track enable/disable changes
    if not aria_enabled and old_aria_enabled:
        # ARIA is being disabled
        case.aria_disabled_at = datetime.utcnow()
        case.aria_disabled_by = current_user.id
    elif aria_enabled and not old_aria_enabled:
        # ARIA is being re-enabled, clear tracking
        case.aria_disabled_at = None
        case.aria_disabled_by = None

    await db.commit()
    await db.refresh(case)

    return {
        "aria_enabled": case.aria_enabled,
        "aria_provider": case.aria_provider,
        "aria_disabled_at": case.aria_disabled_at,
        "aria_disabled_by": case.aria_disabled_by,
        "message": f"ARIA settings updated. ARIA is now {'enabled' if aria_enabled else 'disabled'}."
    }
